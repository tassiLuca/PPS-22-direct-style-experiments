<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>direct-style-experiments</title>
    <link>https://tassiluca.github.io/direct-style-experiments/</link>
    <description>Recent content on direct-style-experiments</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://tassiluca.github.io/direct-style-experiments/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://tassiluca.github.io/direct-style-experiments/docs/01-overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tassiluca.github.io/direct-style-experiments/docs/01-overview/</guid>
      <description>Overview of the project # Context # In the realm of asynchronous programming, the Scala ecosystem offers a set of solid and widely adopted monadic constructs and libraries to tackle complex tasks functionally with elegance and efficiency, like Monix Tasks and Cats Effecs, enabling a wide range of interesting and useful features, like composable error handling, cancellation mechanisms and structured concurrency that the standard library lacks. However, they also come with a cost: the pervasiveness of the flatMap operator to compose values makes the code harder to reason about and difficult and awkward to integrate with regular control structures.</description>
    </item>
    <item>
      <title></title>
      <link>https://tassiluca.github.io/direct-style-experiments/docs/02-boundaries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tassiluca.github.io/direct-style-experiments/docs/02-boundaries/</guid>
      <description>boundary &amp;amp; break # boundary &amp;amp; break Modeling error handling data types with non-local breaks Optional Either + ? boundary &amp;amp; break mechanism provides a cleaner alternative to non-local returns:&#xA;boundary: is short for boundary.apply: the indented code below, passed as body, is a context function that is called within boundary.apply to break, an in-scope given instance of Label is required (i.e. is impossible to break without an enclosing boundary) Users don&amp;rsquo;t define Label instances themselves.</description>
    </item>
    <item>
      <title></title>
      <link>https://tassiluca.github.io/direct-style-experiments/docs/03-basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tassiluca.github.io/direct-style-experiments/docs/03-basics/</guid>
      <description>Basic asynchronous constructs # Basic asynchronous constructs The need for a new Future construct Example: a blog posts service Structure Current monadic Future Direct style: Scala version with gears Direct style vs. monadic style comparison w.r.t. composition Kotlin Coroutines Takeaways The need for a new Future construct # The current implementation of the Future monadic construct suffers the following main cons:&#xA;Lack of referential transparency; Lack of cancellation mechanisms and structured concurrency; Accidental Sequentiality.</description>
    </item>
    <item>
      <title></title>
      <link>https://tassiluca.github.io/direct-style-experiments/docs/04-channels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tassiluca.github.io/direct-style-experiments/docs/04-channels/</guid>
      <description>Channels as a communication primitive # Channels as a communication primitive Introduction Analyzer example Future monadic version Scala Gears version Kotlin Coroutines version Introducing Flows in Gears Showcasing Flows Takeaways Introduction # The fourth, yet not mentioned, abstraction of both Kotlin Coroutines and Scala Gears is the channel. Channels represent the primitive communication and coordination means to exchange Future (or coroutines in the case of Kotlin) results. They are, at least conceptually, very similar to a queue where it is possible to send (and receive) data &amp;ndash; basically, exploiting the producer-consumer pattern.</description>
    </item>
    <item>
      <title></title>
      <link>https://tassiluca.github.io/direct-style-experiments/docs/05-rears/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://tassiluca.github.io/direct-style-experiments/docs/05-rears/</guid>
      <description>Reactivity in direct style # So far, we&amp;rsquo;ve explored the basics of asynchronous abstraction mechanisms provided by the direct style of the Scala Gears and Kotlin Coroutines frameworks. The goal of this last example is to investigate, using a simple example, whether these two frameworks offer sufficient idiomatic abstractions to deal with event-based reactive systems.&#xA;Smart Hub example # Idea: in an IoT context, a multitude of sensors of different types, each replicated to ensure accuracy, transmit their measurements to a central hub, which in turn needs to react, in real-time, forwarding to the appropriate controller the data, possibly performing some kind of transformation.</description>
    </item>
  </channel>
</rss>
