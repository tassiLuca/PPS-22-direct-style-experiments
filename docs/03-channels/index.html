<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Channels as a communication primitive # The fourth, yet not mentioned, abstraction of both Kotlin Coroutines and Scala Gears is the channel. Channels represent the primitive communication and coordination means to exchange Future results. They are, at least conceptually, very similar to a queue where it is possible to send (and receive) data &ndash; basically, exploiting the producer-consumer pattern.
classDiagram class `SendableChannel[-T]` { &lt;&lt; trait &gt;&gt; &#43;sendSource(x: T) Async.Source[Either[Closed, Unit]] &#43;send(x: T)(using Async) Unit } class `ReadableChannel[&#43;T]` { &lt;&lt; trait &gt;&gt; &#43;readSource Async.">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="" />
<meta property="og:description" content="Channels as a communication primitive # The fourth, yet not mentioned, abstraction of both Kotlin Coroutines and Scala Gears is the channel. Channels represent the primitive communication and coordination means to exchange Future results. They are, at least conceptually, very similar to a queue where it is possible to send (and receive) data &ndash; basically, exploiting the producer-consumer pattern.
classDiagram class `SendableChannel[-T]` { &lt;&lt; trait &gt;&gt; &#43;sendSource(x: T) Async.Source[Either[Closed, Unit]] &#43;send(x: T)(using Async) Unit } class `ReadableChannel[&#43;T]` { &lt;&lt; trait &gt;&gt; &#43;readSource Async." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tassiluca.github.io/PPS-22-direct-style-experiments/docs/03-channels/" /><meta property="article:section" content="docs" />

<meta property="article:modified_time" content="2024-02-20T17:51:00+01:00" />

<title>03 Channels | PPS-22-direct-style-experiments</title>
<link rel="manifest" href="/PPS-22-direct-style-experiments/manifest.json">
<link rel="icon" href="/PPS-22-direct-style-experiments/favicon.png" >
<link rel="canonical" href="https://tassiluca.github.io/PPS-22-direct-style-experiments/docs/03-channels/">
<link rel="stylesheet" href="/PPS-22-direct-style-experiments/book.min.f8de3645fe00591b41524aee174e19edd98a22255a2930a0cdc82a94835ba387.css" integrity="sha256-&#43;N42Rf4AWRtBUkruF04Z7dmKIiVaKTCgzcgqlINbo4c=" crossorigin="anonymous">
  <script defer src="/PPS-22-direct-style-experiments/flexsearch.min.js"></script>
  <script defer src="/PPS-22-direct-style-experiments/en.search.min.f60533e2e6ae0e59e0b77f564770888a0169da831bb7ea73b324d82427bf03ec.js" integrity="sha256-9gUz4uauDlngt39WR3CIigFp2oMbt&#43;pzsyTYJCe/A&#43;w=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/PPS-22-direct-style-experiments/"><span>PPS-22-direct-style-experiments</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/PPS-22-direct-style-experiments/docs/01-boundaries/" class="">01 Boundaries</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/PPS-22-direct-style-experiments/docs/02-blog-posts-ws/" class="">02 Blog Posts Ws</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/PPS-22-direct-style-experiments/docs/03-channels/" class="active">03 Channels</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/PPS-22-direct-style-experiments/docs/04-rears/" class="">04 Rears</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/PPS-22-direct-style-experiments/docs/05-going-further/" class="">05 Going Further</a>
  

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/PPS-22-direct-style-experiments/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>03 Channels</strong>

  <label for="toc-control">
    
    <img src="/PPS-22-direct-style-experiments/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#organization-analyzer-example">Organization analyzer example</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="channels-as-a-communication-primitive">
  Channels as a communication primitive
  <a class="anchor" href="#channels-as-a-communication-primitive">#</a>
</h1>
<p>The fourth, yet not mentioned, abstraction of both Kotlin Coroutines and Scala Gears is the <strong>channel</strong>.
Channels represent the primitive communication and coordination means to exchange <code>Future</code> results. They are, at least conceptually, very similar to a queue where it is possible to send (and receive) data &ndash; basically, exploiting the <em><strong>producer-consumer</strong></em> pattern.</p>


<script src="/PPS-22-direct-style-experiments/mermaid.min.js"></script>

  <script>mermaid.initialize({
    "flowchart": {
        "useMaxWidth":true
    },
    "theme": "default"
})</script>




<p class="mermaid">
classDiagram
  class `SendableChannel[-T]` {
    << trait >>
    +sendSource(x: T) Async.Source[Either[Closed, Unit]]
    +send(x: T)(using Async) Unit
  }

  class `ReadableChannel[+T]` {
    << trait >>
    +readSource Async.Source[Either[Closed, T]]
    +read()(using Async) Either[Closed, T]
  }

  class `Channel[T]` {
    << trait >>
    +asSendable: SendableChannel[T]
    +asReadable: ReadableChannel[T]
    +asCloseable: java.io.Closeable
  }

  namespace java io {
    class Closeable {
      << interface >>
      +close()
    }
  }

  `SendableChannel[-T]` <|-- `Channel[T]`
  Closeable <|-- `Channel[T]`
  `ReadableChannel[+T]` <|-- `Channel[T]`
</p>

<p>The channel is defined through three distinct interfaces: <code>SendableChannel[-T]</code>, <code>ReadableChannel[+T]</code> and <code>Channel[T]</code>, where the latter extends from both <code>SendableChannel</code> and <code>ReadableChannel</code>. Typically, a <code>Channel</code> is created and a <code>SendableChannel</code> and <code>ReadableChannel</code> instances are respectively provided to the producer and the consumer, restricting their access to it. The same design is present also in Kotlin Coroutines.</p>
<p>Moreover, <code>Channel</code> inherits from <code>java.io.Closable</code>, making them closable objects: once closed, they raise <code>ChannelClosedException</code> when attempting to write to it and immediately return a <code>Failure(ChannelClosedException)</code> when attempting to read from it.</p>
<p>Three types of channels exist:</p>
<ul>
<li><strong>Synchronous Channels</strong>: links a read request with a send request within a <em>rendezvous</em>
<ul>
<li><code>send</code> (<code>send</code>) suspend the process until a consumer <code>read</code> (<code>send</code>) the value;</li>
</ul>
</li>
<li><strong>Buffered Channels</strong>: a version of a channel with an internal buffer of fixed size
<ul>
<li><code>send</code> suspend the producer process if it is full; otherwise, it appends the value to the buffer, returning immediately;</li>
<li><code>read</code> suspend if the channel is empty, waiting for a new value.</li>
</ul>
</li>
<li><strong>Unbounded Channels</strong>: a version of a channel with an unbounded buffer
<ul>
<li>if the programs run out of memory you can get an out-of-memory exception!</li>
</ul>
</li>
</ul>
<blockquote>
<p>Multiple producers can send data to the channel, as well as multiple consumers can read them, <strong>but each element is handled only <em>once</em>, by <em>one</em> of them</strong>, i.e. consumers <strong>compete</strong> with each other for sent values. Once the element is handled, it is immediately removed from the channel.</p>
</blockquote>
<h2 id="organization-analyzer-example">
  Organization analyzer example
  <a class="anchor" href="#organization-analyzer-example">#</a>
</h2>
<p>To show channels in action an example has been prepared:</p>
<blockquote class="book-hint info">
  <strong>Idea</strong>: we want to realize a little asynchronous library allowing clients to collect the common statistics about repositories (issues, stars, last release) and contributors of a given GitHub organization.
</blockquote>

<p>Final result:</p>
<figure><img src="../res/img/analyzer-e2e.png"/><figcaption>
            <h4>An elephant at sunset</h4>
        </figcaption>
</figure>

<p><img src="../analyzer-e2e.png" alt="" /></p>
<p>As usual, the example has been implemented using monadic <code>Future</code>s, as well as Scala gears and Kotlin Coroutines, and is composed by two</p>
<hr>
<ul>
<li>Channels in Kotlin (w.r.t. gears)
<ul>
<li>fairness (also in Gears?)</li>
<li>pipeline (not supported in Gears)</li>
<li>better closable</li>
</ul>
</li>
</ul>
<hr>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/tassiLuca/PPS-22-direct-style-experiments/commit/f9cefa1e1010a65382adf659bb3410a24e3d0572" title='Last modified by Luca Tassinari | February 20, 2024' target="_blank" rel="noopener">
      <img src="/PPS-22-direct-style-experiments/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>February 20, 2024</span>
    </a>
  </div>




</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#organization-analyzer-example">Organization analyzer example</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












